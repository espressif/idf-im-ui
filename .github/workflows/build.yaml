name: Unified Build Workflow

on:
  schedule: [cron: "0 02 * * *"]
  pull_request:
    branches:
      - master
    paths-ignore:
      - "dl_page/**"
      - "docs/**"
      - ".github/workflows/dl_page.yml"
      - ".github/workflows/docs_build.yml"
  release:
    types:
      - created
  workflow_dispatch:

jobs:
  setup:
    name: Setup and Check merged PRs (schedule only)
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Check PR merge to master in last 24 hours
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName !== 'schedule') {
              core.info(`Workflow triggered by ${context.eventName}, skipping PR checks.`)
              core.setOutput('should_run', 'true');
              return;
            }
            const since = new Date(Date.now() - 24*60*60*1000).toISOString();
            const query = [
              "repo:" + context.repo.owner + "/" + context.repo.repo,
              "is:pr",
              "is:merged",
              `merged:>=${since}`
            ].join(" ")

            const results = await github.rest.search.issuesAndPullRequests({
              q: query,
              per_page: 1
            })

            const count = results.data.total_count
            core.info(`Found ${count} merged PR(s) in last 24 hours`)

            const shouldRun = count > 0 ? "true" : "false"
            core.info(`should_run = ${shouldRun}`)
            core.setOutput("should_run", shouldRun)

      - name: Set up build matrix
        id: set-matrix
        run: |
          matrix='{"include":[{"os":"ubuntu-22.04","package_name":"linux-x64","target":"","use_container":true},{"os":"ubuntu-22.04-arm","package_name":"linux-aarch64","target":"aarch64-unknown-linux-gnu","use_container":true},{"os":"windows-latest","package_name":"windows-x64","target":"","use_container":false},{"os":"macos-latest","package_name":"macos-aarch64","target":"aarch64-apple-darwin","use_container":false},{"os":"macos-15-intel","package_name":"macos-x64","target":"x86_64-apple-darwin","use_container":false}]}'
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  build-test-lib:
    name: Build and Test Library (${{ matrix.package_name }})
    needs: setup
    if: github.event_name != 'schedule' || needs.setup.outputs.should_run == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install OpenSSL (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          echo "VCPKG_ROOT=$env:VCPKG_INSTALLATION_ROOT" >> $env:GITHUB_ENV
          vcpkg install openssl:x64-windows-static-md

      - name: Install dependencies (Linux)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y libssl-dev patchelf

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Build and Test Library
        if: runner.os != 'Windows'
        run: |
          cd src-tauri
          cargo test --no-fail-fast --no-default-features --lib ${{ matrix.target && format('--target {0}', matrix.target) || '' }} 2>&1 | tee lib-result.txt
        shell: bash
        continue-on-error: true

      - name: Format test results
        if: runner.os != 'Windows'
        uses: hahihula/rust-test-results-formatter@v1
        with:
          results-file: "./src-tauri/lib-result.txt"

  build-cli-linux:
    name: Build CLI (Linux - ${{ matrix.package_name }})
    needs: [setup, build-test-lib]
    if: (needs.build-test-lib.result == 'success' || needs.build-test-lib.result == 'skipped')
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            package_name: linux-x64
            target: ""
          - os: ubuntu-24.04-arm
            package_name: linux-aarch64
            target: aarch64-unknown-linux-musl
    container:
      image: clux/muslrust:stable
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          apt-get update
          apt-get install -y libssl-dev patchelf zip

      - name: Build CLI
        env:
          LIBZ_SYS_STATIC: 1
          ZLIB_STATIC: 1
          LZMA_API_STATIC: 1
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: |
          cd src-tauri
          unset PKG_CONFIG_PATH && export ZLIB_STATIC=1 && export LZMA_API_STATIC=1 && export LIBZ_SYS_STATIC=1 && cargo build --release --no-default-features --features cli ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Create release directory
        run: mkdir -p release_cli/${{ matrix.package_name }}

      - name: Copy binary
        run: |
          cp src-tauri/target/${{ matrix.target || 'x86_64-unknown-linux-musl' }}/release/eim release_cli/${{ matrix.package_name }}/eim
          chmod +x release_cli/${{ matrix.package_name }}/eim
          cd release_cli/${{ matrix.package_name }}
          zip -r eim.zip eim
        shell: bash

      - name: Generate Completions
        shell: bash
        run: |
          set -euo pipefail
          cd src-tauri

          # Determine target output from cargo
          TRIPLE="${{ matrix.target }}"
          if [ -z "$TRIPLE" ]; then
            TRIPLE="x86_64-unknown-linux-musl"
          fi

          REAL_TGT="target/$TRIPLE/release"
          BIN="$REAL_TGT/eim"

          ls -la "$REAL_TGT"
          test -f "$BIN" || { echo "eim binary not found at $BIN" >&2; exit 1; }

          OUTDIR="$REAL_TGT/completions"
          mkdir -p "$OUTDIR"
          "$BIN" completions zsh > "$OUTDIR/_eim"
          "$BIN" completions bash > "$OUTDIR/eim.bash"
          "$BIN" completions fish > "$OUTDIR/eim.fish"
          "$BIN" completions elvish > "$OUTDIR/eim.elv"

          mkdir -p target/release/completions
          cp -a "$OUTDIR"/. target/release/completions/

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: eim-cli-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: release_cli/${{ matrix.package_name }}/eim

      - name: Upload Release Asset - Unix
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os != 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/eim.zip
          asset_name: eim-cli-${{ matrix.package_name }}.zip

      # offline installer
      - name: Build offline_installer_builder
        run: |
          cd src-tauri
          cargo build --release --no-default-features --features offline --bin offline_installer_builder ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Copy offline_installer_builder binary
        run: |
          cp src-tauri/target/${{ matrix.target || 'x86_64-unknown-linux-musl' }}/release/offline_installer_builder release_cli/${{ matrix.package_name }}/offline_installer_builder
          chmod +x release_cli/${{ matrix.package_name }}/offline_installer_builder
          cd release_cli/${{ matrix.package_name }}
          zip -r offline_installer_builder.zip offline_installer_builder
        shell: bash

      - name: Upload offline_installer_builder artifacts
        uses: actions/upload-artifact@v4
        with:
          name: offline_installer_builder-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: release_cli/${{ matrix.package_name }}/offline_installer_builder

      - name: Upload offline_installer_builder Release Asset - Unix
        if: github.event_name == 'release' && github.event.action == 'created'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/offline_installer_builder.zip
          asset_name: offline_installer_builder-${{ matrix.package_name }}.zip

      - name: Prepare manpage for deb package
        if: github.event_name == 'release' && github.event.action == 'created'
        run: |
          mkdir -p src-tauri/man
          cp man/eim.1 src-tauri/man/
        shell: bash

      - name: Build CLI .deb package
        run: |
          cd src-tauri
          # Install cargo-deb if not present
          cargo install cargo-deb || true
          # Build .deb with version from tag
          # Use tag version only when ref is a tag
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            VERSION="${GITHUB_REF_NAME#v}"
          else
            VERSION="0.0.0-${GITHUB_SHA:0:7}"
          fi

          echo "Using version: $VERSION"

          cargo deb --no-build --no-default-features --features cli \
            --target ${{ matrix.target || 'x86_64-unknown-linux-musl' }} \
            --deb-version $VERSION
        shell: bash

      - name: Upload CLI .deb artifact
        uses: actions/upload-artifact@v4
        with:
          name: eim-cli-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-deb
          path: src-tauri/target/debian/eim*.deb
          if-no-files-found: warn

      - name: Upload CLI .deb Release Asset
        if: github.event_name == 'release' && github.event.action == 'created'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/debian/eim*.deb
          asset_name: eim-cli-${{ matrix.package_name }}.deb

      - name: Build CLI .rpm package
        run: |
          cd src-tauri
          # Install cargo-generate-rpm if not present
          cargo install cargo-generate-rpm || true
          # Use tag version only when ref is a tag
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            VERSION="${GITHUB_REF_NAME#v}"
          else
            VERSION="0.0.0-${GITHUB_SHA:0:7}"
          fi

          echo "Using version: $VERSION"


          # Create .rpmbuild directory structure
          mkdir -p ~/.rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}

          # Generate RPM with proper configuration
          cargo generate-rpm \
            --target ${{ matrix.target || 'x86_64-unknown-linux-musl' }} \
            --payload-compress gzip \

          # Debug: Show what was generated
          echo "Generated RPM files:"
          find target -name "*.rpm" -type f
        shell: bash

      - name: Find and upload RPM artifacts
        id: find-rpms
        run: |
          # Find all RPM files and copy them to a known location
          RPM_DIR="rpm_output"
          mkdir -p "$RPM_DIR"

          # Search for RPM files in all possible locations
          find src-tauri/target -name "*.rpm" -type f -exec cp {} "$RPM_DIR/" \;

          echo "Contents of $RPM_DIR:"
          ls -la "$RPM_DIR"/

          # List all found RPM files
          if [ -d "$RPM_DIR" ] && [ "$(ls -A $RPM_DIR)" ]; then
            echo "rpm_files_found=true" >> $GITHUB_OUTPUT
            echo "rpm_count=$(ls $RPM_DIR/*.rpm 2>/dev/null | wc -l)" >> $GITHUB_OUTPUT
            echo "rpm_dir=$RPM_DIR" >> $GITHUB_OUTPUT
          else
            echo "rpm_files_found=false" >> $GITHUB_OUTPUT
            echo "No RPM files found!" >&2
            exit 1
          fi

      - name: Upload RPM artifacts to workflow
        if: steps.find-rpms.outputs.rpm_files_found == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: eim-cli-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-rpm
          path: rpm_output/*.rpm
          if-no-files-found: warn

      - name: Upload CLI .rpm Release Assets
        if: github.event_name == 'release' && github.event.action == 'created' && steps.find-rpms.outputs.rpm_files_found == 'true'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: rpm_output/*.rpm
          asset_name: eim-cli-${{ matrix.package_name }}.rpm

  build-cli:
    name: Build CLI (${{ matrix.package_name }})
    needs: [setup, build-test-lib]
    if: (needs.build-test-lib.result == 'success' || needs.build-test-lib.result == 'skipped')
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            package_name: windows-x64
            target: ""
          - os: macos-latest
            package_name: macos-aarch64
            target: aarch64-apple-darwin
          - os: macos-15-intel
            package_name: macos-x64
            target: x86_64-apple-darwin
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@nightly
        if: matrix.os == 'macos-aarch64'
        with:
          targets: ${{ matrix.target }}

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        if: matrix.os == 'macos-x64'
        with:
          targets: ${{ matrix.target }}

      - name: Set up Perl (Windows)
        if: runner.os == 'Windows'
        uses: shogo82148/actions-setup-perl@v1
        with:
          perl-version: "5.38"

      - name: Install Perl dependencies (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          cpan App::cpanminus
          cpanm --force Locale::Maketext::Simple
          cpanm --force Text::Template
          cpanm --force Params::Check
          cpanm --force IPC::Cmd
          perl -MLocale::Maketext::Simple -e "print 'Locale::Maketext::Simple loaded successfully\n'"
          perl -MText::Template -e "print 'Text::Template loaded successfully\n'"
          perl -MParams::Check -e "print 'Params::Check loaded successfully\n'"
          perl -MIPC::Cmd -e "print 'IPC::Cmd loaded successfully\n'"
          $perl_lib_path = "C:\hostedtoolcache\windows\perl\5.38.5-thr\x64\site\lib"
          echo "PERL5LIB=$perl_lib_path" >> $env:GITHUB_ENV

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Build CLI
        if: runner.os == 'Windows'
        env:
          OPENSSL_DIR: 'C:\vcpkg\installed\x64-windows-static-md'
          OPENSSL_LIB_DIR: 'C:\vcpkg\installed\x64-windows-static-md\lib'
          OPENSSL_INCLUDE_DIR: 'C:\vcpkg\installed\x64-windows-static-md\include'
          OPENSSL_STATIC: "1"
          PERL: 'C:\\hostedtoolcache\\windows\\perl\\5.38.5-thr\\x64\\bin\\perl.exe'
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: |
          cd src-tauri
          cargo build --release --no-default-features --features cli ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Build CLI
        if: startsWith(matrix.os, 'macos')
        env:
          LIBZ_SYS_STATIC: 1
          ZLIB_STATIC: 1
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: |
          cd src-tauri
          unset PKG_CONFIG_PATH && export ZLIB_STATIC=1 && export LZMA_API_STATIC=1 && export LIBZ_SYS_STATIC=1 && cargo build --release --no-default-features --features cli ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Create release directory
        run: mkdir -p release_cli/${{ matrix.package_name }}

      - name: Copy binary (Windows)
        if: runner.os == 'Windows'
        run: copy src-tauri\target\release\eim.exe release_cli\${{ matrix.package_name }}\eim.exe
        shell: cmd

      - name: Copy binary (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          cp src-tauri/target/${{ matrix.target }}/release/eim release_cli/${{ matrix.package_name }}/eim
          chmod +x release_cli/${{ matrix.package_name }}/eim
          cd release_cli/${{ matrix.package_name }}
          zip -r eim.zip eim
        shell: bash

      - name: Install .NET 8 SDK and AzureSignTool
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          mkdir dotnet
          cd dotnet
          $dotnet_url="https://download.visualstudio.microsoft.com/download/pr/5af098e1-e433-4fda-84af-3f54fd27c108/6bd1c6e48e64e64871957289023ca590/dotnet-sdk-8.0.302-win-x64.zip"
          Invoke-WebRequest -Uri $dotnet_url -OutFile dotnet-sdk-8.0.302-win-x64.zip
          Expand-Archive -LiteralPath .\dotnet-sdk-8.0.302-win-x64.zip -DestinationPath .
          $Env:DOTNET_ROOT="$($(Get-Location).Path)\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"
          $Env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE=$true
          dotnet tool install --global AzureSignTool
          cd ..

      - name: Sign Windows Binary
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "release_cli\${{ matrix.package_name }}\eim.exe"
          if (-not (Test-Path $exePath)) { throw "eim.exe not found at $exePath" }

          $Env:DOTNET_ROOT="$PWD\dotnet\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"

          AzureSignTool.exe sign `
            -kvu "${{ secrets.AZURE_KEYVAULT_URI }}" `
            -kvc "${{ secrets.AZURE_KEYVAULT_CERT_NAME }}" `
            -kvi "${{ secrets.AZURE_CLIENT_ID }}" `
            -kvs "${{ secrets.AZURE_CLIENT_SECRET }}" `
            --azure-key-vault-tenant-id "${{ secrets.AZURE_TENANT_ID }}" `
            -tr http://timestamp.globalsign.com/tsa/advanced `
            -td sha256 `
            "$exePath"

      - name: Verify Signature
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "release_cli\${{ matrix.package_name }}\eim.exe"
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Name "signtool.exe" | Select-Object -First 1
          & "C:\Program Files (x86)\Windows Kits\$signtool" verify `
          /pa `
          "$exePath"

      - name: Codesign macOS Binary
        if: startsWith(matrix.os, 'macos')
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
        run: |
          echo $MACOS_CERTIFICATE | base64 --decode > certificate.p12
          security list-keychains | grep -q "build.keychain" || security create-keychain -p espressif build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p espressif build.keychain
          security import certificate.p12 -k build.keychain -P $MACOS_CERTIFICATE_PWD -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k espressif build.keychain
          codesign --entitlements eim.entitlement --options runtime --force -s "ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD. (QWXF6GB4AV)" release_cli/${{ matrix.package_name }}/eim -v
          codesign -v -vvv --deep release_cli/${{ matrix.package_name }}/eim

      - name: Notarize macOS Binary
        if: startsWith(matrix.os, 'macos') && github.event_name == 'release'
        env:
          NOTARIZATION_USERNAME: ${{ secrets.NOTARIZATION_USERNAME }}
          NOTARIZATION_PASSWORD: ${{ secrets.NOTARIZATION_PASSWORD }}
          NOTARIZATION_TEAM_ID: ${{ secrets.NOTARIZATION_TEAM_ID }}
        run: |
          cd release_cli/${{ matrix.package_name }}
          zip -r eim.zip eim
          security create-keychain -p espressif notary.keychain
          security default-keychain -s notary.keychain
          security unlock-keychain -p espressif notary.keychain
          xcrun notarytool store-credentials "eim-notarytool-profile" --apple-id $NOTARIZATION_USERNAME --team-id $NOTARIZATION_TEAM_ID --password $NOTARIZATION_PASSWORD
          xcrun notarytool submit eim.zip --keychain-profile "eim-notarytool-profile" --wait
          unzip -o eim.zip -d .

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: eim-cli-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: release_cli/${{ matrix.package_name }}/eim${{ runner.os == 'Windows' && '.exe' || '' }}

      - name: Upload Release Asset - MacOs
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os != 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/eim.zip
          asset_name: eim-cli-${{ matrix.package_name }}.zip

      - name: Upload Release Asset (Windows)
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os == 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/eim.exe
          asset_name: eim-cli-${{ matrix.package_name }}.exe

      - name: Build offline_installer_builder (Windows)
        if: runner.os == 'Windows'
        env:
          OPENSSL_DIR: 'C:\vcpkg\installed\x64-windows-static-md'
          OPENSSL_LIB_DIR: 'C:\vcpkg\installed\x64-windows-static-md\lib'
          OPENSSL_INCLUDE_DIR: 'C:\vcpkg\installed\x64-windows-static-md\include'
          OPENSSL_STATIC: "1"
          PERL: 'C:\\hostedtoolcache\\windows\\perl\\5.38.4-thr\\x64\\bin\\perl.exe'
        run: |
          cd src-tauri
          cargo build --release --no-default-features --features offline --bin offline_installer_builder ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Build offline_installer_builder (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          cd src-tauri
          cargo build --release --no-default-features --features offline --bin offline_installer_builder ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Copy offline_installer_builder binary (Windows)
        if: runner.os == 'Windows'
        run: copy src-tauri\target\release\offline_installer_builder.exe release_cli\${{ matrix.package_name }}\offline_installer_builder.exe
        shell: cmd

      - name: Copy offline_installer_builder binary (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          cp src-tauri/target/${{ matrix.target }}/release/offline_installer_builder release_cli/${{ matrix.package_name }}/offline_installer_builder
          chmod +x release_cli/${{ matrix.package_name }}/offline_installer_builder
          cd release_cli/${{ matrix.package_name }}
          zip -r offline_installer_builder.zip offline_installer_builder
        shell: bash

      - name: Sign Windows offline_installer_builder Binary
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "release_cli\${{ matrix.package_name }}\offline_installer_builder.exe"
          if (-not (Test-Path $exePath)) { throw "offline_installer_builder.exe not found at $exePath" }

          $Env:DOTNET_ROOT="$PWD\dotnet\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"

          AzureSignTool.exe sign `
            -kvu "${{ secrets.AZURE_KEYVAULT_URI }}" `
            -kvc "${{ secrets.AZURE_KEYVAULT_CERT_NAME }}" `
            -kvi "${{ secrets.AZURE_CLIENT_ID }}" `
            -kvs "${{ secrets.AZURE_CLIENT_SECRET }}" `
            --azure-key-vault-tenant-id "${{ secrets.AZURE_TENANT_ID }}" `
            -tr http://timestamp.globalsign.com/tsa/advanced `
            -td sha256 `
            "$exePath"

      - name: Verify offline_installer_builder Signature
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "release_cli\${{ matrix.package_name }}\offline_installer_builder.exe"
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Name "signtool.exe" | Select-Object -First 1
          & "C:\Program Files (x86)\Windows Kits\$signtool" verify `
          /pa `
          "$exePath"

      - name: Codesign macOS offline_installer_builder Binary
        if: startsWith(matrix.os, 'macos')
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
        run: |
          echo $MACOS_CERTIFICATE | base64 --decode > certificate_offline.p12
          security create-keychain -p espressif build_offline.keychain
          security default-keychain -s build_offline.keychain
          security unlock-keychain -p espressif build_offline.keychain
          security import certificate_offline.p12 -k build_offline.keychain -P $MACOS_CERTIFICATE_PWD -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k espressif build_offline.keychain
          codesign --entitlements eim.entitlement --options runtime --force -s "ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD. (QWXF6GB4AV)" release_cli/${{ matrix.package_name }}/offline_installer_builder -v
          codesign -v -vvv --deep release_cli/${{ matrix.package_name }}/offline_installer_builder

      - name: Upload offline_installer_builder build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: offline_installer_builder-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: release_cli/${{ matrix.package_name }}/offline_installer_builder${{ runner.os == 'Windows' && '.exe' || '' }}

      - name: Upload offline_installer_builder Release Asset - MacOs
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os != 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/offline_installer_builder.zip
          asset_name: offline_installer_builder-${{ matrix.package_name }}.zip

      - name: Upload offline_installer_builder Release Asset (Windows)
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os == 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/offline_installer_builder.exe
          asset_name: offline_installer_builder-${{ matrix.package_name }}.exe

  build-offline-archives:
    name: Build Offline Archives
    needs: [build-cli, build-cli-linux]
    if: (needs.build-cli.result == 'success' || needs.build-cli.result == 'skipped') && (needs.build-cli-linux.result == 'success' || needs.build-cli-linux.result == 'skipped') && github.event_name == 'release'
    uses: ./.github/workflows/build_offline_installer_archives.yaml
    with:
      ref: ${{ github.ref }}
      run_id: ${{ github.run_id }}
    secrets:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      DL_DISTRIBUTION_ID: ${{ secrets.DL_DISTRIBUTION_ID }}

  build-gui:
    name: Build GUI (${{ matrix.package_name }})
    needs: [setup, build-test-lib]
    if: needs.build-test-lib.result == 'success' || needs.build-test-lib.result == 'skipped'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install OpenSSL (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          echo "VCPKG_ROOT=$env:VCPKG_INSTALLATION_ROOT" >> $env:GITHUB_ENV
          vcpkg install openssl:x64-windows-static-md

      - name: Install dependencies (Linux)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev libssl-dev patchelf

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Install frontend dependencies
        run: yarn install

      - name: Import macOS codesign certs
        if: startsWith(matrix.os, 'macos')
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.MACOS_CERTIFICATE }}
          p12-password: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          keychain: build

      - name: Remove offline_installer_builder from Cargo.toml for GUI build (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          # Remove the specific lines for offline_installer_builder
          sed -i.bak '/^\[\[bin\]\]$/{ N; N; N; /name = "offline_installer_builder"/d; }' src-tauri/Cargo.toml ||
          sed -i.bak '/name = "offline_installer_builder"/{ N; N; s/.*\n.*\n.*//; }' src-tauri/Cargo.toml ||
          # Fallback: remove each line individually
          sed -i.bak '/name = "offline_installer_builder"/,+2d' src-tauri/Cargo.toml
          # Also remove any orphaned [[bin]] line
          sed -i.bak '/^\[\[bin\]\]$/{ N; /path = "src\/offline_installer_builder\.rs"/d; }' src-tauri/Cargo.toml
          rm -f src-tauri/Cargo.toml.bak
          cat src-tauri/Cargo.toml

      - name: Remove offline_installer_builder from Cargo.toml for GUI build (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $content = Get-Content "src-tauri/Cargo.toml" -Raw
          $pattern = '(?s)\[\[bin\]\]\s*name = "offline_installer_builder"\s*path = "src/offline_installer_builder\.rs"\s*required-features = \["offline"\]\s*(?=\n(\[\[bin\]\]|\[|$))'
          $newContent = $content -replace $pattern, ''
          Set-Content "src-tauri/Cargo.toml" -Value $newContent
          Get-Content "src-tauri/Cargo.toml"

      - name: Build GUI (macOS) - release
        if: startsWith(matrix.os, 'macos') && github.event_name == 'release'
        env:
          APPLE_ID: ${{ secrets.NOTARIZATION_USERNAME }}
          APPLE_PASSWORD: ${{ secrets.NOTARIZATION_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.NOTARIZATION_TEAM_ID }}
          LIBZ_SYS_STATIC: 1
          ZLIB_STATIC: 1
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: |
          security create-keychain -p espressif notary.keychain
          security default-keychain -s notary.keychain
          security unlock-keychain -p espressif notary.keychain
          unset PKG_CONFIG_PATH && export ZLIB_STATIC=1 && export LZMA_API_STATIC=1 && export LIBZ_SYS_STATIC=1 && yarn tauri build

      - name: Build GUI (macOS) - non-release
        if: startsWith(matrix.os, 'macos') && github.event_name != 'release'
        env:
          LIBZ_SYS_STATIC: 1
          ZLIB_STATIC: 1
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: unset PKG_CONFIG_PATH && export ZLIB_STATIC=1 && export LZMA_API_STATIC=1 && export LIBZ_SYS_STATIC=1 && yarn tauri build

      - name: Build GUI (non-macOS)
        if: ${{ !startsWith(matrix.os, 'macos') }}
        env:
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: yarn tauri build

      - name: Install .NET 8 SDK and AzureSignTool (GUI)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          mkdir dotnet
          cd dotnet
          $dotnet_url="https://download.visualstudio.microsoft.com/download/pr/5af098e1-e433-4fda-84af-3f54fd27c108/6bd1c6e48e64e64871957289023ca590/dotnet-sdk-8.0.302-win-x64.zip"
          Invoke-WebRequest -Uri $dotnet_url -OutFile dotnet-sdk-8.0.302-win-x64.zip
          Expand-Archive -LiteralPath .\dotnet-sdk-8.0.302-win-x64.zip -DestinationPath .
          $Env:DOTNET_ROOT="$($(Get-Location).Path)\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"
          $Env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE=$true
          dotnet tool install --global AzureSignTool
          cd ..

      - name: Sign Windows Binary (GUI)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "src-tauri\target\release\eim.exe"
          if (-not (Test-Path $exePath)) { throw "eim.exe not found at $exePath" }

          $Env:DOTNET_ROOT="$PWD\dotnet\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"

          AzureSignTool.exe sign `
            -kvu "${{ secrets.AZURE_KEYVAULT_URI }}" `
            -kvc "${{ secrets.AZURE_KEYVAULT_CERT_NAME }}" `
            -kvi "${{ secrets.AZURE_CLIENT_ID }}" `
            -kvs "${{ secrets.AZURE_CLIENT_SECRET }}" `
            --azure-key-vault-tenant-id "${{ secrets.AZURE_TENANT_ID }}" `
            -tr http://timestamp.globalsign.com/tsa/advanced `
            -td sha256 `
            "$exePath"

      - name: Verify Signature (GUI)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "src-tauri\target\release\eim.exe"
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Name "signtool.exe" | Select-Object -First 1
          & "C:\Program Files (x86)\Windows Kits\$signtool" verify `
          /pa `
          "$exePath"

      - name: Handle Linux artifacts
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          chmod +x src-tauri/target/release/eim
          chmod +x src-tauri/target/release/bundle/appimage/*.AppImage
          cd src-tauri/target/release/
          zip -r eim.zip eim

      - name: Handle macOS artifacts
        if: startsWith(matrix.os, 'macos')
        run: |
          chmod +x src-tauri/target/release/bundle/macos/eim.app
          cd src-tauri/target/release/bundle/macos
          zip -r eim.zip eim.app

      - name: Upload Linux artifacts
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: |
            src-tauri/target/release/eim
            # src-tauri/target/release/bundle/appimage/*.AppImage
          if-no-files-found: warn

      - name: Upload Linux artifacts - .deb
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-deb
          path: |
            src-tauri/target/release/bundle/deb/*.deb
            # src-tauri/target/release/bundle/appimage/*.AppImage
          if-no-files-found: warn

      - name: Find and upload Linux RPM artifacts
        if: startsWith(matrix.os, 'ubuntu')
        id: find-gui-rpms
        run: |
          RPM_DIR="gui_rpm_output"
          mkdir -p "$RPM_DIR"

          # Find RPM files in GUI build output
          find src-tauri/target/release/bundle -name "*.rpm" -type f -exec cp {} "$RPM_DIR/" \;

          echo "Contents of $RPM_DIR:"
          ls -la "$RPM_DIR"/

          if [ -d "$RPM_DIR" ] && [ "$(ls -A $RPM_DIR)" ]; then
            echo "gui_rpm_files_found=true" >> $GITHUB_OUTPUT
            echo "gui_rpm_count=$(ls $RPM_DIR/*.rpm 2>/dev/null | wc -l)" >> $GITHUB_OUTPUT
            echo "gui_rpm_dir=$RPM_DIR" >> $GITHUB_OUTPUT
          else
            echo "gui_rpm_files_found=false" >> $GITHUB_OUTPUT
            echo "No GUI RPM files found!" >&2
          fi

      - name: Upload Linux artifacts - .rpm
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-rpm
          path: gui_rpm_output/*.rpm
          if-no-files-found: warn

      - name: Upload Release Assets (Linux - .rpm)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu') && steps.find-gui-rpms.outputs.gui_rpm_files_found == 'true'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: gui_rpm_output/*.rpm
          asset_name: eim-gui-${{ matrix.package_name }}.rpm

      - name: Upload Linux artifacts - .AppImage
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-AppImage
          path: |
            src-tauri/target/release/bundle/appimage/*.AppImage
          if-no-files-found: warn

      - name: Upload macOS artifacts
        if: startsWith(matrix.os, 'macos')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: |
            # src-tauri/target/release/bundle/macos/eim.app
            # src-tauri/target/release/bundle/dmg/*.dmg
            src-tauri/target/release/bundle/macos/*.app
          if-no-files-found: warn

      - name: Upload macOS artifacts - dmg
        if: startsWith(matrix.os, 'macos')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-dmg
          path: |
            src-tauri/target/release/bundle/dmg/*.dmg
          if-no-files-found: warn

      - name: Upload Windows artifacts
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: |
            src-tauri/target/release/eim.exe
            # src-tauri/target/release/bundle/msi/*.msi
          if-no-files-found: warn

      - name: Upload Windows artifacts - msi
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-msi
          path: |
            src-tauri/target/release/bundle/msi/*.msi
          if-no-files-found: warn

      - name: Upload Release Assets (Windows)
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os == 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/eim.exe
          asset_name: eim-gui-${{ matrix.package_name }}.exe

      - name: Upload Release Assets (Windows msi)
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os == 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/msi/*.msi
          asset_name: eim-gui-${{ matrix.package_name }}.msi

      - name: Upload Release Assets (Linux)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/eim.zip
          asset_name: eim-gui-${{ matrix.package_name }}.zip

      - name: Upload Release Assets (Linux - .deb)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/deb/*.deb
          asset_name: eim-gui-${{ matrix.package_name }}.deb

      - name: Upload Release Assets (Linux - .AppImage)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/deb/*.AppImage
          asset_name: eim-gui-${{ matrix.package_name }}.AppImage

      - name: Upload Release Assets (macOS)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'macos')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/macos/eim.zip
          asset_name: eim-gui-${{ matrix.package_name }}.zip

      - name: Upload Release Assets (macOS - dmg)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'macos')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/dmg/*.dmg
          asset_name: eim-gui-${{ matrix.package_name }}.dmg

  Autotest-CLI:
    name: Autotest CLI
    needs: [build-cli, build-cli-linux]
    if: needs.build-cli.result == 'success' && needs.build-cli-linux.result == 'success'
    uses: ./.github/workflows/test_cli.yml
    with:
      run_id: ${{ github.run_id }}
      ref: ${{ github.event.pull_request.head.ref || github.ref }}
      run_extended: ${{(github.event_name == 'release' && github.event.action == 'created') || github.event_name == 'schedule' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'EXTENDEDTEST')) || startsWith(github.event.pull_request.head.ref, 'release')}}
      run_self_hosted: ${{(github.event_name == 'release' && github.event.action == 'created') || github.event_name == 'schedule' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'CNRUNNER'))}}

  Autotest-GUI:
    name: Autotest GUI
    needs: [build-gui]
    if: needs.build-gui.result == 'success'
    uses: ./.github/workflows/test_gui.yml
    with:
      run_id: ${{ github.run_id }}
      ref: ${{ github.event.pull_request.head.ref || github.ref }}
      run_extended: ${{(github.event_name == 'release' && github.event.action == 'created') || github.event_name == 'schedule' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'EXTENDEDTEST')) || startsWith(github.event.pull_request.head.ref, 'release')}}

  update-release-info:
    name: Update Release Information
    needs: [build-cli, build-cli-linux, build-gui]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Fetch latest release info
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-east-1
          DL_DISTRIBUTION_ID: ${{ secrets.DL_DISTRIBUTION_ID }}
        run: |
          # GUI release info
          curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/repos/espressif/idf-im-ui/releases/latest > eim_unified_release.json
          echo "Latest GUI release tag: $(jq -r .tag_name eim_unified_release.json)"
          aws s3 cp --acl=public-read "eim_unified_release.json" s3://espdldata/dl/eim/eim_unified_release.json
          aws cloudfront create-invalidation --distribution-id ${DL_DISTRIBUTION_ID} --paths "/dl/eim/eim_unified_release.json"

  update-homebrew:
    name: Update Homebrew Formula and Cask
    needs: [build-cli, build-cli-linux, build-gui, update-release-info]
    uses: ./.github/workflows/update-homebrew.yml
    with:
      version: ${{ github.ref_name }}
    if: github.event_name == 'release' && github.event.action == 'created'
    secrets: inherit

  update-linux-repos:
    name: Update APT and RPM Repositories
    needs: [build-cli-linux, build-gui, update-release-info]
    uses: ./.github/workflows/update-linux-repos.yml
    if: github.event_name == 'release' && github.event.action == 'created'
    with:
      version: ${{ github.ref_name }}
    secrets: inherit

  update-windows-packages:
    name: Generate Windows Packages and Publish to WinGet
    needs: [build-cli, build-gui, update-release-info]
    uses: ./.github/workflows/update-windows-packages.yml
    if: github.event_name == 'release' && github.event.action == 'created'
    with:
      version: ${{ github.ref_name }}
    secrets: inherit
