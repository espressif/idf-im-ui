name: Unified Build Workflow

on:
  schedule: [cron: "0 02 * * *"]
  pull_request:
    branches:
      - master
    paths-ignore:
      - "dl_page/**"
      - "docs/**"
      - ".github/workflows/dl_page.yml"
      - ".github/workflows/docs_build.yml"
  release:
    types:
      - created
  workflow_dispatch:

jobs:
  setup:
    name: Setup and Check merged PRs (schedule only)
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Check PR merge to master in last 24 hours
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName !== 'schedule') {
              core.info(`Workflow triggered by ${context.eventName}, skipping PR checks.`)
              core.setOutput('should_run', 'true');
              return;
            }
            const since = new Date(Date.now() - 24*60*60*1000).toISOString();
            const query = [
              "repo:" + context.repo.owner + "/" + context.repo.repo,
              "is:pr",
              "is:merged",
              `merged:>=${since}`
            ].join(" ")

            const results = await github.rest.search.issuesAndPullRequests({
              q: query,
              per_page: 1
            })

            const count = results.data.total_count
            core.info(`Found ${count} merged PR(s) in last 24 hours`)

            const shouldRun = count > 0 ? "true" : "false"
            core.info(`should_run = ${shouldRun}`)
            core.setOutput("should_run", shouldRun)

      - name: Set up build matrix
        id: set-matrix
        run: |
          matrix='{"include":[{"os":"ubuntu-22.04","package_name":"linux-x64","target":"","use_container":true},{"os":"ubuntu-22.04-arm","package_name":"linux-aarch64","target":"aarch64-unknown-linux-gnu","use_container":true},{"os":"windows-latest","package_name":"windows-x64","target":"","use_container":false},{"os":"macos-latest","package_name":"macos-aarch64","target":"aarch64-apple-darwin","use_container":false},{"os":"macos-15-intel","package_name":"macos-x64","target":"x86_64-apple-darwin","use_container":false}]}'
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  build-test-lib:
    name: Build and Test Library (${{ matrix.package_name }})
    needs: setup
    if: github.event_name != 'schedule' || needs.setup.outputs.should_run == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install OpenSSL (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          echo "VCPKG_ROOT=$env:VCPKG_INSTALLATION_ROOT" >> $env:GITHUB_ENV
          vcpkg install openssl:x64-windows-static-md

      - name: Install dependencies (Linux)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y libssl-dev patchelf

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') || 'no-lock' }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Build and Test Library
        if: runner.os != 'Windows'
        run: |
          cd src-tauri
          cargo test --no-fail-fast --no-default-features --lib ${{ matrix.target && format('--target {0}', matrix.target) || '' }} 2>&1 | tee lib-result.txt
        shell: bash
        continue-on-error: true

      - name: Format test results
        if: runner.os != 'Windows'
        uses: hahihula/rust-test-results-formatter@v1
        with:
          results-file: "./src-tauri/lib-result.txt"

  build-cli-linux:
    name: Build CLI (Linux - ${{ matrix.package_name }})
    needs: [setup, build-test-lib]
    if: (needs.build-test-lib.result == 'success' || needs.build-test-lib.result == 'skipped')
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            package_name: linux-x64
            target: ""
          - os: ubuntu-24.04-arm
            package_name: linux-aarch64
            target: aarch64-unknown-linux-musl
    container:
      image: clux/muslrust:stable
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          apt-get update
          apt-get install -y libssl-dev patchelf zip

      - name: Build CLI
        env:
          LIBZ_SYS_STATIC: 1
          ZLIB_STATIC: 1
          LZMA_API_STATIC: 1
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: |
          cd src-tauri
          unset PKG_CONFIG_PATH && export ZLIB_STATIC=1 && export LZMA_API_STATIC=1 && export LIBZ_SYS_STATIC=1 && cargo build --release --no-default-features --features cli ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Create release directory
        run: mkdir -p release_cli/${{ matrix.package_name }}

      - name: Copy binary
        run: |
          cp src-tauri/target/${{ matrix.target || 'x86_64-unknown-linux-musl' }}/release/eim release_cli/${{ matrix.package_name }}/eim
          chmod +x release_cli/${{ matrix.package_name }}/eim
          cd release_cli/${{ matrix.package_name }}
          zip -r eim.zip eim
        shell: bash

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: eim-cli-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: release_cli/${{ matrix.package_name }}/eim

      - name: Upload Release Asset - Unix
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os != 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/eim.zip
          asset_name: eim-cli-${{ matrix.package_name }}.zip
      # offline installer
      - name: Build offline_installer_builder
        run: |
          cd src-tauri
          cargo build --release --no-default-features --features offline --bin offline_installer_builder ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Copy offline_installer_builder binary
        run: |
          cp src-tauri/target/${{ matrix.target || 'x86_64-unknown-linux-musl' }}/release/offline_installer_builder release_cli/${{ matrix.package_name }}/offline_installer_builder
          chmod +x release_cli/${{ matrix.package_name }}/offline_installer_builder
          cd release_cli/${{ matrix.package_name }}
          zip -r offline_installer_builder.zip offline_installer_builder
        shell: bash

      - name: Upload offline_installer_builder artifacts
        uses: actions/upload-artifact@v4
        with:
          name: offline_installer_builder-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: release_cli/${{ matrix.package_name }}/offline_installer_builder

      - name: Upload offline_installer_builder Release Asset - Unix
        if: github.event_name == 'release' && github.event.action == 'created'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/offline_installer_builder.zip
          asset_name: offline_installer_builder-${{ matrix.package_name }}.zip

      - name: Prepare manpage for deb package
        if: github.event_name == 'release' && github.event.action == 'created'
        run: |
          mkdir -p src-tauri/man
          cp man/eim.1 src-tauri/man/
        shell: bash

      - name: Build CLI .deb package
        if: github.event_name == 'release' && github.event.action == 'created'
        run: |
          cd src-tauri
          # Install cargo-deb if not present
          cargo install cargo-deb || true
          # Build .deb with version from tag
          VERSION=$(echo ${{ github.ref_name }} | sed 's/v//')
          cargo deb --no-build --no-default-features --features cli \
            --target ${{ matrix.target || 'x86_64-unknown-linux-musl' }} \
            --deb-version $VERSION
        shell: bash

      - name: Upload CLI .deb artifact
        if: github.event_name == 'release' && github.event.action == 'created'
        uses: actions/upload-artifact@v4
        with:
          name: eim-cli-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-deb
          path: src-tauri/target/debian/eim*.deb
          if-no-files-found: warn

      - name: Upload CLI .deb Release Asset
        if: github.event_name == 'release' && github.event.action == 'created'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/debian/eim*.deb
          asset_name: eim-cli-${{ matrix.package_name }}.deb

      - name: Build CLI .rpm package
        if: github.event_name == 'release' && github.event.action == 'created'
        run: |
          cd src-tauri
          # Install cargo-generate-rpm if not present
          cargo install cargo-generate-rpm || true
          # Build .rpm with version from tag
          VERSION=$(echo ${{ github.ref_name }} | sed 's/v//')
          cargo generate-rpm --target ${{ matrix.target || 'x86_64-unknown-linux-musl' }} \
            --payload-compress gzip
        shell: bash

      - name: Upload CLI .rpm artifact
        if: github.event_name == 'release' && github.event.action == 'created'
        uses: actions/upload-artifact@v4
        with:
          name: eim-cli-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-rpm
          path: src-tauri/target/generate-rpm/*.rpm
          if-no-files-found: warn

      - name: Upload CLI .rpm Release Asset
        if: github.event_name == 'release' && github.event.action == 'created'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/generate-rpm/*.rpm
          asset_name: eim-cli-${{ matrix.package_name }}.rpm

  build-cli:
    name: Build CLI (${{ matrix.package_name }})
    needs: [setup, build-test-lib]
    if: (needs.build-test-lib.result == 'success' || needs.build-test-lib.result == 'skipped')
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            package_name: windows-x64
            target: ""
          - os: macos-latest
            package_name: macos-aarch64
            target: aarch64-apple-darwin
          - os: macos-15-intel
            package_name: macos-x64
            target: x86_64-apple-darwin
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@nightly
        if: matrix.os == 'macos-aarch64'
        with:
          targets: ${{ matrix.target }}

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        if: matrix.os == 'macos-x64'
        with:
          targets: ${{ matrix.target }}

      - name: Set up Perl (Windows)
        if: runner.os == 'Windows'
        uses: shogo82148/actions-setup-perl@v1
        with:
          perl-version: "5.38"

      - name: Install Perl dependencies (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          cpan App::cpanminus
          cpanm --force Locale::Maketext::Simple
          cpanm --force Text::Template
          cpanm --force Params::Check
          cpanm --force IPC::Cmd
          perl -MLocale::Maketext::Simple -e "print 'Locale::Maketext::Simple loaded successfully\n'"
          perl -MText::Template -e "print 'Text::Template loaded successfully\n'"
          perl -MParams::Check -e "print 'Params::Check loaded successfully\n'"
          perl -MIPC::Cmd -e "print 'IPC::Cmd loaded successfully\n'"
          $perl_lib_path = "C:\hostedtoolcache\windows\perl\5.38.5-thr\x64\site\lib"
          echo "PERL5LIB=$perl_lib_path" >> $env:GITHUB_ENV

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Build CLI
        if: runner.os == 'Windows'
        env:
          OPENSSL_DIR: 'C:\vcpkg\installed\x64-windows-static-md'
          OPENSSL_LIB_DIR: 'C:\vcpkg\installed\x64-windows-static-md\lib'
          OPENSSL_INCLUDE_DIR: 'C:\vcpkg\installed\x64-windows-static-md\include'
          OPENSSL_STATIC: "1"
          PERL: 'C:\\hostedtoolcache\\windows\\perl\\5.38.5-thr\\x64\\bin\\perl.exe'
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: |
          cd src-tauri
          cargo build --release --no-default-features --features cli ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Build CLI
        if: startsWith(matrix.os, 'macos')
        env:
          LIBZ_SYS_STATIC: 1
          ZLIB_STATIC: 1
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: |
          cd src-tauri
          unset PKG_CONFIG_PATH && export ZLIB_STATIC=1 && export LZMA_API_STATIC=1 && export LIBZ_SYS_STATIC=1 && cargo build --release --no-default-features --features cli ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Create release directory
        run: mkdir -p release_cli/${{ matrix.package_name }}

      - name: Copy binary (Windows)
        if: runner.os == 'Windows'
        run: copy src-tauri\target\release\eim.exe release_cli\${{ matrix.package_name }}\eim.exe
        shell: cmd

      - name: Copy binary (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          cp src-tauri/target/${{ matrix.target }}/release/eim release_cli/${{ matrix.package_name }}/eim
          chmod +x release_cli/${{ matrix.package_name }}/eim
          cd release_cli/${{ matrix.package_name }}
          zip -r eim.zip eim
        shell: bash

      - name: Install .NET 8 SDK and AzureSignTool
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          mkdir dotnet
          cd dotnet
          $dotnet_url="https://download.visualstudio.microsoft.com/download/pr/5af098e1-e433-4fda-84af-3f54fd27c108/6bd1c6e48e64e64871957289023ca590/dotnet-sdk-8.0.302-win-x64.zip"
          Invoke-WebRequest -Uri $dotnet_url -OutFile dotnet-sdk-8.0.302-win-x64.zip
          Expand-Archive -LiteralPath .\dotnet-sdk-8.0.302-win-x64.zip -DestinationPath .
          $Env:DOTNET_ROOT="$($(Get-Location).Path)\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"
          $Env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE=$true
          dotnet tool install --global AzureSignTool
          cd ..

      - name: Sign Windows Binary
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "release_cli\${{ matrix.package_name }}\eim.exe"
          if (-not (Test-Path $exePath)) { throw "eim.exe not found at $exePath" }

          $Env:DOTNET_ROOT="$PWD\dotnet\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"

          AzureSignTool.exe sign `
            -kvu "${{ secrets.AZURE_KEYVAULT_URI }}" `
            -kvc "${{ secrets.AZURE_KEYVAULT_CERT_NAME }}" `
            -kvi "${{ secrets.AZURE_CLIENT_ID }}" `
            -kvs "${{ secrets.AZURE_CLIENT_SECRET }}" `
            --azure-key-vault-tenant-id "${{ secrets.AZURE_TENANT_ID }}" `
            -tr http://timestamp.globalsign.com/tsa/advanced `
            -td sha256 `
            "$exePath"

      - name: Verify Signature
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "release_cli\${{ matrix.package_name }}\eim.exe"
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Name "signtool.exe" | Select-Object -First 1
          & "C:\Program Files (x86)\Windows Kits\$signtool" verify `
          /pa `
          "$exePath"

      - name: Codesign macOS Binary
        if: startsWith(matrix.os, 'macos')
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
        run: |
          echo $MACOS_CERTIFICATE | base64 --decode > certificate.p12
          security list-keychains | grep -q "build.keychain" || security create-keychain -p espressif build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p espressif build.keychain
          security import certificate.p12 -k build.keychain -P $MACOS_CERTIFICATE_PWD -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k espressif build.keychain
          codesign --entitlements eim.entitlement --options runtime --force -s "ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD. (QWXF6GB4AV)" release_cli/${{ matrix.package_name }}/eim -v
          codesign -v -vvv --deep release_cli/${{ matrix.package_name }}/eim

      - name: Notarize macOS Binary
        if: startsWith(matrix.os, 'macos') && github.event_name == 'release'
        env:
          NOTARIZATION_USERNAME: ${{ secrets.NOTARIZATION_USERNAME }}
          NOTARIZATION_PASSWORD: ${{ secrets.NOTARIZATION_PASSWORD }}
          NOTARIZATION_TEAM_ID: ${{ secrets.NOTARIZATION_TEAM_ID }}
        run: |
          cd release_cli/${{ matrix.package_name }}
          zip -r eim.zip eim
          security create-keychain -p espressif notary.keychain
          security default-keychain -s notary.keychain
          security unlock-keychain -p espressif notary.keychain
          xcrun notarytool store-credentials "eim-notarytool-profile" --apple-id $NOTARIZATION_USERNAME --team-id $NOTARIZATION_TEAM_ID --password $NOTARIZATION_PASSWORD
          xcrun notarytool submit eim.zip --keychain-profile "eim-notarytool-profile" --wait
          unzip -o eim.zip -d .

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: eim-cli-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: release_cli/${{ matrix.package_name }}/eim${{ runner.os == 'Windows' && '.exe' || '' }}

      - name: Upload Release Asset - MacOs
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os != 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/eim.zip
          asset_name: eim-cli-${{ matrix.package_name }}.zip

      - name: Upload Release Asset (Windows)
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os == 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/eim.exe
          asset_name: eim-cli-${{ matrix.package_name }}.exe

      - name: Build offline_installer_builder (Windows)
        if: runner.os == 'Windows'
        env:
          OPENSSL_DIR: 'C:\vcpkg\installed\x64-windows-static-md'
          OPENSSL_LIB_DIR: 'C:\vcpkg\installed\x64-windows-static-md\lib'
          OPENSSL_INCLUDE_DIR: 'C:\vcpkg\installed\x64-windows-static-md\include'
          OPENSSL_STATIC: "1"
          PERL: 'C:\\hostedtoolcache\\windows\\perl\\5.38.4-thr\\x64\\bin\\perl.exe'
        run: |
          cd src-tauri
          cargo build --release --no-default-features --features offline --bin offline_installer_builder ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Build offline_installer_builder (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          cd src-tauri
          cargo build --release --no-default-features --features offline --bin offline_installer_builder ${{ matrix.target && format('--target {0}', matrix.target) || '' }}
        shell: bash

      - name: Copy offline_installer_builder binary (Windows)
        if: runner.os == 'Windows'
        run: copy src-tauri\target\release\offline_installer_builder.exe release_cli\${{ matrix.package_name }}\offline_installer_builder.exe
        shell: cmd

      - name: Copy offline_installer_builder binary (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          cp src-tauri/target/${{ matrix.target }}/release/offline_installer_builder release_cli/${{ matrix.package_name }}/offline_installer_builder
          chmod +x release_cli/${{ matrix.package_name }}/offline_installer_builder
          cd release_cli/${{ matrix.package_name }}
          zip -r offline_installer_builder.zip offline_installer_builder
        shell: bash

      - name: Sign Windows offline_installer_builder Binary
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "release_cli\${{ matrix.package_name }}\offline_installer_builder.exe"
          if (-not (Test-Path $exePath)) { throw "offline_installer_builder.exe not found at $exePath" }

          $Env:DOTNET_ROOT="$PWD\dotnet\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"

          AzureSignTool.exe sign `
            -kvu "${{ secrets.AZURE_KEYVAULT_URI }}" `
            -kvc "${{ secrets.AZURE_KEYVAULT_CERT_NAME }}" `
            -kvi "${{ secrets.AZURE_CLIENT_ID }}" `
            -kvs "${{ secrets.AZURE_CLIENT_SECRET }}" `
            --azure-key-vault-tenant-id "${{ secrets.AZURE_TENANT_ID }}" `
            -tr http://timestamp.globalsign.com/tsa/advanced `
            -td sha256 `
            "$exePath"

      - name: Verify offline_installer_builder Signature
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "release_cli\${{ matrix.package_name }}\offline_installer_builder.exe"
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Name "signtool.exe" | Select-Object -First 1
          & "C:\Program Files (x86)\Windows Kits\$signtool" verify `
          /pa `
          "$exePath"

      - name: Codesign macOS offline_installer_builder Binary
        if: startsWith(matrix.os, 'macos')
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
        run: |
          echo $MACOS_CERTIFICATE | base64 --decode > certificate_offline.p12
          security create-keychain -p espressif build_offline.keychain
          security default-keychain -s build_offline.keychain
          security unlock-keychain -p espressif build_offline.keychain
          security import certificate_offline.p12 -k build_offline.keychain -P $MACOS_CERTIFICATE_PWD -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k espressif build_offline.keychain
          codesign --entitlements eim.entitlement --options runtime --force -s "ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD. (QWXF6GB4AV)" release_cli/${{ matrix.package_name }}/offline_installer_builder -v
          codesign -v -vvv --deep release_cli/${{ matrix.package_name }}/offline_installer_builder

      - name: Upload offline_installer_builder build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: offline_installer_builder-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: release_cli/${{ matrix.package_name }}/offline_installer_builder${{ runner.os == 'Windows' && '.exe' || '' }}

      - name: Upload offline_installer_builder Release Asset - MacOs
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os != 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/offline_installer_builder.zip
          asset_name: offline_installer_builder-${{ matrix.package_name }}.zip

      - name: Upload offline_installer_builder Release Asset (Windows)
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os == 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release_cli/${{ matrix.package_name }}/offline_installer_builder.exe
          asset_name: offline_installer_builder-${{ matrix.package_name }}.exe

  build-offline-archives:
    name: Build Offline Archives
    needs: [build-cli, build-cli-linux]
    if: (needs.build-cli.result == 'success' || needs.build-cli.result == 'skipped') && (needs.build-cli-linux.result == 'success' || needs.build-cli-linux.result == 'skipped') && github.event_name == 'release'
    uses: ./.github/workflows/build_offline_installer_archives.yaml
    with:
      ref: ${{ github.ref }}
      run_id: ${{ github.run_id }}
    secrets:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      DL_DISTRIBUTION_ID: ${{ secrets.DL_DISTRIBUTION_ID }}

  build-gui:
    name: Build GUI (${{ matrix.package_name }})
    needs: [setup, build-test-lib]
    if: needs.build-test-lib.result == 'success' || needs.build-test-lib.result == 'skipped'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install OpenSSL (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          echo "VCPKG_ROOT=$env:VCPKG_INSTALLATION_ROOT" >> $env:GITHUB_ENV
          vcpkg install openssl:x64-windows-static-md

      - name: Install dependencies (Linux)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev libssl-dev patchelf

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Install frontend dependencies
        run: yarn install

      - name: Import macOS codesign certs
        if: startsWith(matrix.os, 'macos')
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.MACOS_CERTIFICATE }}
          p12-password: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          keychain: build

      - name: Remove offline_installer_builder from Cargo.toml for GUI build (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          # Remove the specific lines for offline_installer_builder
          sed -i.bak '/^\[\[bin\]\]$/{ N; N; N; /name = "offline_installer_builder"/d; }' src-tauri/Cargo.toml ||
          sed -i.bak '/name = "offline_installer_builder"/{ N; N; s/.*\n.*\n.*//; }' src-tauri/Cargo.toml ||
          # Fallback: remove each line individually
          sed -i.bak '/name = "offline_installer_builder"/,+2d' src-tauri/Cargo.toml
          # Also remove any orphaned [[bin]] line
          sed -i.bak '/^\[\[bin\]\]$/{ N; /path = "src\/offline_installer_builder\.rs"/d; }' src-tauri/Cargo.toml
          rm -f src-tauri/Cargo.toml.bak
          cat src-tauri/Cargo.toml

      - name: Remove offline_installer_builder from Cargo.toml for GUI build (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $content = Get-Content "src-tauri/Cargo.toml" -Raw
          $pattern = '(?s)\[\[bin\]\]\s*name = "offline_installer_builder"\s*path = "src/offline_installer_builder\.rs"\s*required-features = \["offline"\]\s*(?=\n(\[\[bin\]\]|\[|$))'
          $newContent = $content -replace $pattern, ''
          Set-Content "src-tauri/Cargo.toml" -Value $newContent
          Get-Content "src-tauri/Cargo.toml"

      - name: Build GUI (macOS) - release
        if: startsWith(matrix.os, 'macos') && github.event_name == 'release'
        env:
          APPLE_ID: ${{ secrets.NOTARIZATION_USERNAME }}
          APPLE_PASSWORD: ${{ secrets.NOTARIZATION_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.NOTARIZATION_TEAM_ID }}
          LIBZ_SYS_STATIC: 1
          ZLIB_STATIC: 1
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: |
          security create-keychain -p espressif notary.keychain
          security default-keychain -s notary.keychain
          security unlock-keychain -p espressif notary.keychain
          unset PKG_CONFIG_PATH && export ZLIB_STATIC=1 && export LZMA_API_STATIC=1 && export LIBZ_SYS_STATIC=1 && yarn tauri build

      - name: Build GUI (macOS) - non-release
        if: startsWith(matrix.os, 'macos') && github.event_name != 'release'
        env:
          LIBZ_SYS_STATIC: 1
          ZLIB_STATIC: 1
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: unset PKG_CONFIG_PATH && export ZLIB_STATIC=1 && export LZMA_API_STATIC=1 && export LIBZ_SYS_STATIC=1 && yarn tauri build

      - name: Build GUI (non-macOS)
        if: ${{ !startsWith(matrix.os, 'macos') }}
        env:
          APP_INSIGHTS_CONNECTION_STRING: ${{ secrets.APP_INSIGHTS_CONNECTION_STRING }}
        run: yarn tauri build

      - name: Install .NET 8 SDK and AzureSignTool (GUI)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          mkdir dotnet
          cd dotnet
          $dotnet_url="https://download.visualstudio.microsoft.com/download/pr/5af098e1-e433-4fda-84af-3f54fd27c108/6bd1c6e48e64e64871957289023ca590/dotnet-sdk-8.0.302-win-x64.zip"
          Invoke-WebRequest -Uri $dotnet_url -OutFile dotnet-sdk-8.0.302-win-x64.zip
          Expand-Archive -LiteralPath .\dotnet-sdk-8.0.302-win-x64.zip -DestinationPath .
          $Env:DOTNET_ROOT="$($(Get-Location).Path)\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"
          $Env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE=$true
          dotnet tool install --global AzureSignTool
          cd ..

      - name: Sign Windows Binary (GUI)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "src-tauri\target\release\eim.exe"
          if (-not (Test-Path $exePath)) { throw "eim.exe not found at $exePath" }

          $Env:DOTNET_ROOT="$PWD\dotnet\dotnet-sdk-8.0.302-win-x64"
          $Env:PATH="$Env:DOTNET_ROOT;$Env:PATH"

          AzureSignTool.exe sign `
            -kvu "${{ secrets.AZURE_KEYVAULT_URI }}" `
            -kvc "${{ secrets.AZURE_KEYVAULT_CERT_NAME }}" `
            -kvi "${{ secrets.AZURE_CLIENT_ID }}" `
            -kvs "${{ secrets.AZURE_CLIENT_SECRET }}" `
            --azure-key-vault-tenant-id "${{ secrets.AZURE_TENANT_ID }}" `
            -tr http://timestamp.globalsign.com/tsa/advanced `
            -td sha256 `
            "$exePath"

      - name: Verify Signature (GUI)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $exePath = Join-Path $PWD "src-tauri\target\release\eim.exe"
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits" -Recurse -Name "signtool.exe" | Select-Object -First 1
          & "C:\Program Files (x86)\Windows Kits\$signtool" verify `
          /pa `
          "$exePath"

      - name: Handle Linux artifacts
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          chmod +x src-tauri/target/release/eim
          chmod +x src-tauri/target/release/bundle/appimage/*.AppImage
          cd src-tauri/target/release/
          zip -r eim.zip eim

      - name: Handle macOS artifacts
        if: startsWith(matrix.os, 'macos')
        run: |
          chmod +x src-tauri/target/release/bundle/macos/eim.app
          cd src-tauri/target/release/bundle/macos
          zip -r eim.zip eim.app

      - name: Upload Linux artifacts
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: |
            src-tauri/target/release/eim
            # src-tauri/target/release/bundle/deb/*.deb
            # src-tauri/target/release/bundle/rpm/*.rpm
            # src-tauri/target/release/bundle/appimage/*.AppImage
          if-no-files-found: warn

      - name: Upload Linux artifacts - .deb
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-deb
          path: |
            src-tauri/target/release/bundle/deb/*.deb
            # src-tauri/target/release/bundle/rpm/*.rpm
            # src-tauri/target/release/bundle/appimage/*.AppImage
          if-no-files-found: warn

      - name: Upload Linux artifacts - .rpm
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-rpm
          path: |
            src-tauri/target/release/bundle/rpm/*.rpm
            # src-tauri/target/release/bundle/appimage/*.AppImage
          if-no-files-found: warn

      - name: Upload Release Assets (Linux - .rpm)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/rpm/*.rpm
          asset_name: eim-gui-${{ matrix.package_name }}.rpm

      - name: Upload Linux artifacts - .AppImage
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-AppImage
          path: |
            src-tauri/target/release/bundle/appimage/*.AppImage
          if-no-files-found: warn

      - name: Upload macOS artifacts
        if: startsWith(matrix.os, 'macos')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: |
            # src-tauri/target/release/bundle/macos/eim.app
            # src-tauri/target/release/bundle/dmg/*.dmg
            src-tauri/target/release/bundle/macos/*.app
          if-no-files-found: warn

      - name: Upload macOS artifacts - dmg
        if: startsWith(matrix.os, 'macos')
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-dmg
          path: |
            src-tauri/target/release/bundle/dmg/*.dmg
          if-no-files-found: warn

      - name: Upload Windows artifacts
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}
          path: |
            src-tauri/target/release/eim.exe
            # src-tauri/target/release/bundle/msi/*.msi
          if-no-files-found: warn

      - name: Upload Windows artifacts - msi
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: eim-gui-${{ matrix.package_name }}-${{ (github.event_name == 'release' && github.ref_name) || github.run_number }}-msi
          path: |
            src-tauri/target/release/bundle/msi/*.msi
          if-no-files-found: warn

      - name: Upload Release Assets (Windows)
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os == 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/eim.exe
          asset_name: eim-gui-${{ matrix.package_name }}.exe

      - name: Upload Release Assets (Windows msi)
        if: github.event_name == 'release' && github.event.action == 'created' && runner.os == 'Windows'
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/msi/*.msi
          asset_name: eim-gui-${{ matrix.package_name }}.msi

      - name: Upload Release Assets (Linux)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/eim.zip
          asset_name: eim-gui-${{ matrix.package_name }}.zip

      - name: Upload Release Assets (Linux - .deb)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/deb/*.deb
          asset_name: eim-gui-${{ matrix.package_name }}.deb

      - name: Upload Release Assets (Linux - .rpm)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/deb/*.rpm
          asset_name: eim-gui-${{ matrix.package_name }}.rpm

      - name: Upload Release Assets (Linux - .AppImage)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'ubuntu')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/deb/*.AppImage
          asset_name: eim-gui-${{ matrix.package_name }}.AppImage

      - name: Upload Release Assets (macOS)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'macos')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/macos/eim.zip
          asset_name: eim-gui-${{ matrix.package_name }}.zip

      - name: Upload Release Assets (macOS - dmg)
        if: github.event_name == 'release' && github.event.action == 'created' && startsWith(matrix.os, 'macos')
        uses: shogo82148/actions-upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: src-tauri/target/release/bundle/dmg/*.dmg
          asset_name: eim-gui-${{ matrix.package_name }}.dmg

  Autotest-CLI:
    name: Autotest CLI
    needs: [build-cli, build-cli-linux]
    if: needs.build-cli.result == 'success' && needs.build-cli-linux.result == 'success'
    uses: ./.github/workflows/test_cli.yml
    with:
      run_id: ${{ github.run_id }}
      ref: ${{ github.event.pull_request.head.ref || github.ref }}
      run_extended: ${{(github.event_name == 'release' && github.event.action == 'created') || github.event_name == 'schedule' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'EXTENDEDTEST')) || startsWith(github.event.pull_request.head.ref, 'release')}}
      run_self_hosted: ${{(github.event_name == 'release' && github.event.action == 'created') || github.event_name == 'schedule' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'CNRUNNER'))}}

  Autotest-GUI:
    name: Autotest GUI
    needs: [build-gui]
    if: needs.build-gui.result == 'success'
    uses: ./.github/workflows/test_gui.yml
    with:
      run_id: ${{ github.run_id }}
      ref: ${{ github.event.pull_request.head.ref || github.ref }}
      run_extended: ${{(github.event_name == 'release' && github.event.action == 'created') || github.event_name == 'schedule' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'EXTENDEDTEST')) || startsWith(github.event.pull_request.head.ref, 'release')}}

  update-release-info:
    name: Update Release Information
    needs: [build-cli, build-cli-linux, build-gui]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Fetch latest release info
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-east-1
          DL_DISTRIBUTION_ID: ${{ secrets.DL_DISTRIBUTION_ID }}
        run: |
          # GUI release info
          curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/repos/espressif/idf-im-ui/releases/latest > eim_unified_release.json
          echo "Latest GUI release tag: $(jq -r .tag_name eim_unified_release.json)"
          aws s3 cp --acl=public-read "eim_unified_release.json" s3://espdldata/dl/eim/eim_unified_release.json
          aws cloudfront create-invalidation --distribution-id ${DL_DISTRIBUTION_ID} --paths "/dl/eim/eim_unified_release.json"

  update-homebrew:
    name: Update Homebrew Formula and Cask
    needs: [build-cli, build-cli-linux, build-gui, update-release-info]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'created'
    steps:
      - name: Checkout main repository
        uses: actions/checkout@v4
        with:
          path: main-repo

      - name: Checkout homebrew repository
        uses: actions/checkout@v4
        with:
          repository: espressif/homebrew-eim
          token: ${{ secrets.HOMEBREW_UPDATE_TOKEN }}
          path: homebrew-repo

      - name: Get release information
        id: release-info
        run: |
          echo "tag_name=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          echo "release_url=${{ github.event.release.html_url }}" >> $GITHUB_OUTPUT

      - name: Download and calculate checksums for CLI
        id: cli-checksums
        run: |
          # Download CLI binaries and calculate SHA256
          wget -q "${{ github.event.release.assets_url }}" -O assets.json

          # Authenticate the request to get proper asset URLs
          ASSETS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "${{ github.event.release.assets_url }}")

          # macOS x64 CLI
          macos_x64_url=$(echo "$ASSETS" | jq -r '.[] | select(.name == "eim-cli-macos-x64.zip") | .browser_download_url')
          wget -q "$macos_x64_url" -O eim-cli-macos-x64.zip
          macos_x64_sha=$(sha256sum eim-cli-macos-x64.zip | cut -d' ' -f1)

          # macOS ARM64 CLI
          macos_arm64_url=$(echo "$ASSETS" | jq -r '.[] | select(.name == "eim-cli-macos-aarch64.zip") | .browser_download_url')
          wget -q "$macos_arm64_url" -O eim-cli-macos-aarch64.zip
          macos_arm64_sha=$(sha256sum eim-cli-macos-aarch64.zip | cut -d' ' -f1)

          echo "macos_x64_url=$macos_x64_url" >> $GITHUB_OUTPUT
          echo "macos_x64_sha=$macos_x64_sha" >> $GITHUB_OUTPUT
          echo "macos_arm64_url=$macos_arm64_url" >> $GITHUB_OUTPUT
          echo "macos_arm64_sha=$macos_arm64_sha" >> $GITHUB_OUTPUT

      - name: Download and calculate checksums for GUI
        id: gui-checksums
        run: |
          ASSETS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "${{ github.event.release.assets_url }}")

          # macOS x64 GUI (DMG)
          macos_x64_gui_url=$(echo "$ASSETS" | jq -r '.[] | select(.name == "eim-gui-macos-x64.dmg") | .browser_download_url')
          wget -q "$macos_x64_gui_url" -O eim-gui-macos-x64.dmg
          macos_x64_gui_sha=$(sha256sum eim-gui-macos-x64.dmg | cut -d' ' -f1)

          # macOS ARM64 GUI (DMG)
          macos_arm64_gui_url=$(echo "$ASSETS" | jq -r '.[] | select(.name == "eim-gui-macos-aarch64.dmg") | .browser_download_url')
          wget -q "$macos_arm64_gui_url" -O eim-gui-macos-aarch64.dmg
          macos_arm64_gui_sha=$(sha256sum eim-gui-macos-aarch64.dmg | cut -d' ' -f1)

          echo "macos_x64_gui_url=$macos_x64_gui_url" >> $GITHUB_OUTPUT
          echo "macos_x64_gui_sha=$macos_x64_gui_sha" >> $GITHUB_OUTPUT
          echo "macos_arm64_gui_url=$macos_arm64_gui_url" >> $GITHUB_OUTPUT
          echo "macos_arm64_gui_sha=$macos_arm64_gui_sha" >> $GITHUB_OUTPUT

      - name: Generate Homebrew Formula for CLI
        env:
          VERSION: ${{ steps.release-info.outputs.tag_name }}
          MACOS_X64_URL: ${{ steps.cli-checksums.outputs.macos_x64_url }}
          MACOS_X64_SHA: ${{ steps.cli-checksums.outputs.macos_x64_sha }}
          MACOS_ARM64_URL: ${{ steps.cli-checksums.outputs.macos_arm64_url }}
          MACOS_ARM64_SHA: ${{ steps.cli-checksums.outputs.macos_arm64_sha }}
        run: |
          mkdir -p homebrew-repo/Formula

          # Remove 'v' prefix from version for formula
          CLEAN_VERSION="${VERSION#v}"

          cat > homebrew-repo/Formula/eim.rb << 'FORMULA_EOF'
          # typed: false
          # frozen_string_literal: true

          class Eim < Formula
            desc "ESP-IDF Installation Manager - CLI tool for setting up ESP-IDF development environment"
            homepage "https://github.com/espressif/idf-im-ui"
          FORMULA_EOF

                    cat >> homebrew-repo/Formula/eim.rb << FORMULA_EOF
            version "${CLEAN_VERSION}"
            license "MIT"

            on_macos do
              on_intel do
                url "${MACOS_X64_URL}"
                sha256 "${MACOS_X64_SHA}"
              end
              on_arm do
                url "${MACOS_ARM64_URL}"
                sha256 "${MACOS_ARM64_SHA}"
              end
            end

            # Runtime dependencies for QEMU (used by ESP-IDF for emulation)
            depends_on "libgcrypt"
            depends_on "glib"
            depends_on "pixman"
            depends_on "sdl2"
            depends_on "libslirp"

            # DFU utility for flashing
            depends_on "dfu-util"

            # ESP-IDF requires Python 3.9-3.13. We install python@3.12 as default.
            # If user already has python@3.12, Homebrew won't reinstall it.
            depends_on "python@3.12"

            def install
              bin.install "eim"
            end

            def caveats
              <<~EOS
                ESP-IDF Installation Manager (EIM) has been installed.

                Python 3.12 was installed as a dependency (ESP-IDF requires Python 3.9-3.13).
                Python 3.14+ is not yet supported.

                Run 'eim' to install ESP-IDF.
              EOS
            end

            test do
              assert_match "eim", shell_output("#{bin}/eim --version")
            end
          end
          FORMULA_EOF

          echo "Generated CLI formula:"
          cat homebrew-repo/Formula/eim.rb

      - name: Generate Homebrew Cask for GUI
        env:
          VERSION: ${{ steps.release-info.outputs.tag_name }}
          MACOS_X64_GUI_URL: ${{ steps.gui-checksums.outputs.macos_x64_gui_url }}
          MACOS_X64_GUI_SHA: ${{ steps.gui-checksums.outputs.macos_x64_gui_sha }}
          MACOS_ARM64_GUI_URL: ${{ steps.gui-checksums.outputs.macos_arm64_gui_url }}
          MACOS_ARM64_GUI_SHA: ${{ steps.gui-checksums.outputs.macos_arm64_gui_sha }}
        run: |
          mkdir -p homebrew-repo/Casks

          # Remove 'v' prefix from version for cask
          CLEAN_VERSION="${VERSION#v}"

          cat > homebrew-repo/Casks/eim-gui.rb << CASK_EOF
          cask "eim-gui" do
            version "${CLEAN_VERSION}"

            on_intel do
              url "${MACOS_X64_GUI_URL}"
              sha256 "${MACOS_X64_GUI_SHA}"
            end
            on_arm do
              url "${MACOS_ARM64_GUI_URL}"
              sha256 "${MACOS_ARM64_GUI_SHA}"
            end

            name "ESP-IDF Installation Manager"
            desc "GUI application for installing and managing ESP-IDF development environment"
            homepage "https://github.com/espressif/idf-im-ui"

            app "eim.app"

            caveats <<~EOS
              ESP-IDF Installation Manager (EIM) has been installed.

              IMPORTANT: ESP-IDF requires Python 3.9, 3.10, 3.11, 3.12, or 3.13.
              Python 3.14+ is not yet supported.

              If you don't have a compatible Python version, install one with:
                brew install python@3.12

              For QEMU emulation support, you may also need:
                brew install libgcrypt glib pixman sdl2 libslirp dfu-util
            EOS

            zap trash: [
              "~/Library/Application Support/com.espressif.eim",
              "~/Library/Caches/com.espressif.eim",
              "~/Library/Preferences/com.espressif.eim.plist",
              "~/Library/Saved Application State/com.espressif.eim.savedState",
            ]
          end
          CASK_EOF

          echo "Generated GUI cask:"
          cat homebrew-repo/Casks/eim-gui.rb

      - name: Commit and push changes
        run: |
          cd homebrew-repo
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add Formula/eim.rb Casks/eim-gui.rb
          git diff --staged --quiet || git commit -m "Update eim to version ${{ steps.release-info.outputs.tag_name }}"
          git push

  update-apt-repo:
    name: Update APT Repository on S3
    needs: [build-cli-linux, build-gui, update-release-info]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'created'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-east-1

      - name: Install dependencies for APT repo tools
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev apt-utils gzip

      - name: Download GUI linux-x64 .deb artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-gui-linux-x64-${{ github.ref_name }}-deb
          path: new-debs/

      - name: Download GUI linux-aarch64 .deb artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-gui-linux-aarch64-${{ github.ref_name }}-deb
          path: new-debs/
        continue-on-error: true

      - name: Download CLI linux-x64 .deb artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-cli-linux-x64-${{ github.ref_name }}-deb
          path: new-debs/

      - name: Download CLI linux-aarch64 .deb artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-cli-linux-aarch64-${{ github.ref_name }}-deb
          path: new-debs/
        continue-on-error: true

      - name: Create proper APT repository structure
        run: |
          # Create proper directory structure
          mkdir -p apt-repo/pool/main
          mkdir -p apt-repo/dists/stable/main/binary-amd64
          mkdir -p apt-repo/dists/stable/main/binary-arm64

          # Sync existing .deb files from S3 pool
          aws s3 sync s3://espdldata/dl/eim/apt/pool/main/ apt-repo/pool/main/ --exclude "*" --include "*.deb" || echo "No existing pool found"

          # Copy new .deb files to pool
          find new-debs -name "*.deb" -exec cp {} apt-repo/pool/main/ \; || echo "Warning: Some .deb files could not be copied"

          # Debug: Show what's in the pool
          echo "Pool contents:"
          ls -la apt-repo/pool/main/

      - name: Generate APT repository metadata
        working-directory: apt-repo
        run: |
          # Generate Packages files for each architecture
          # AMD64 packages
          dpkg-scanpackages --arch amd64 pool/main > dists/stable/main/binary-amd64/Packages
          gzip -k -f dists/stable/main/binary-amd64/Packages

          # ARM64 packages
          dpkg-scanpackages --arch arm64 pool/main > dists/stable/main/binary-arm64/Packages
          gzip -k -f dists/stable/main/binary-arm64/Packages

          # Generate Release file
          cd dists/stable
          cat > Release << EOF
          Origin: Espressif Systems
          Label: ESP-IDF Installation Manager
          Suite: stable
          Codename: stable
          Architectures: amd64 arm64
          Components: main
          Description: ESP-IDF Installation Manager packages
          Date: $(date -Ru)
          EOF

          # Add file hashes to Release
          apt-ftparchive release . >> Release

          echo "Generated Release file:"
          cat Release

      - name: Upload repository to S3
        run: |
          # Upload the entire repository structure
          aws s3 sync apt-repo/ s3://espdldata/dl/eim/apt/ --acl public-read --delete

          # Verify upload
          echo "Uploaded repository structure:"
          aws s3 ls s3://espdldata/dl/eim/apt/ --recursive

      - name: Invalidate CloudFront cache
        env:
          DL_DISTRIBUTION_ID: ${{ secrets.DL_DISTRIBUTION_ID }}
        run: |
          aws cloudfront create-invalidation --distribution-id ${DL_DISTRIBUTION_ID} --paths "/dl/eim/apt/*"

  update-rpm-repo:
    name: Update RPM Repository on S3
    needs: [build-cli-linux, build-gui, update-release-info]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'created'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-east-1

      - name: Install createrepo_c for RPM repo management
        run: |
          sudo apt-get update
          sudo apt-get install -y createrepo-c rpm

      - name: Download GUI linux-x64 .rpm artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-gui-linux-x64-${{ github.ref_name }}-rpm
          path: new-rpms/
        continue-on-error: true

      - name: Download GUI linux-aarch64 .rpm artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-gui-linux-aarch64-${{ github.ref_name }}-rpm
          path: new-rpms/
        continue-on-error: true

      - name: Download CLI linux-x64 .rpm artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-cli-linux-x64-${{ github.ref_name }}-rpm
          path: new-rpms/

      - name: Download CLI linux-aarch64 .rpm artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-cli-linux-aarch64-${{ github.ref_name }}-rpm
          path: new-rpms/
        continue-on-error: true

      - name: Create RPM repository structure
        run: |
          # Create directory structure
          mkdir -p rpm-repo/x86_64
          mkdir -p rpm-repo/aarch64

          # Sync existing .rpm files from S3
          aws s3 sync s3://espdldata/dl/eim/rpm/x86_64/ rpm-repo/x86_64/ --exclude "*" --include "*.rpm" || echo "No existing x86_64 RPMs found"
          aws s3 sync s3://espdldata/dl/eim/rpm/aarch64/ rpm-repo/aarch64/ --exclude "*" --include "*.rpm" || echo "No existing aarch64 RPMs found"

          # Copy new .rpm files to appropriate architecture directories
          find new-rpms -name "*x86_64*.rpm" -exec cp {} rpm-repo/x86_64/ \; || echo "No x86_64 RPMs to copy"
          find new-rpms -name "*aarch64*.rpm" -exec cp {} rpm-repo/aarch64/ \; || echo "No aarch64 RPMs to copy"

          # Debug: Show what's in the repo
          echo "x86_64 RPMs:"
          ls -la rpm-repo/x86_64/
          echo "aarch64 RPMs:"
          ls -la rpm-repo/aarch64/

      - name: Generate RPM repository metadata
        working-directory: rpm-repo
        run: |
          # Generate metadata for x86_64
          if [ -n "$(ls -A x86_64/*.rpm 2>/dev/null)" ]; then
            createrepo_c x86_64/
          else
            echo "No x86_64 RPMs found, skipping metadata generation"
          fi

          # Generate metadata for aarch64
          if [ -n "$(ls -A aarch64/*.rpm 2>/dev/null)" ]; then
            createrepo_c aarch64/
          else
            echo "No aarch64 RPMs found, skipping metadata generation"
          fi

      - name: Create repo file
        run: |
          cat > rpm-repo/eim.repo << EOF
          [eim]
          name=ESP-IDF Installation Manager
          baseurl=https://dl.espressif.com/dl/eim/rpm/\$basearch
          enabled=1
          gpgcheck=0
          EOF

          echo "Generated eim.repo:"
          cat rpm-repo/eim.repo

      - name: Upload repository to S3
        run: |
          # Upload the entire repository structure
          aws s3 sync rpm-repo/ s3://espdldata/dl/eim/rpm/ --acl public-read --delete

          # Verify upload
          echo "Uploaded repository structure:"
          aws s3 ls s3://espdldata/dl/eim/rpm/ --recursive

      - name: Invalidate CloudFront cache
        env:
          DL_DISTRIBUTION_ID: ${{ secrets.DL_DISTRIBUTION_ID }}
        run: |
          aws cloudfront create-invalidation --distribution-id ${DL_DISTRIBUTION_ID} --paths "/dl/eim/rpm/*"

  generate-windows-packages:
    name: Generate Windows Packages (Scoop)
    needs: [build-cli, build-gui, update-release-info]
    runs-on: windows-latest
    if: github.event_name == 'release' && github.event.action == 'created'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download CLI windows-x64 artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-cli-windows-x64-${{ github.ref_name }}
          path: artifacts/cli/

      - name: Download GUI windows-x64 artifact
        uses: actions/download-artifact@v4
        with:
          name: eim-gui-windows-x64-${{ github.ref_name }}
          path: artifacts/gui/

      - name: Generate Scoop manifests
        shell: powershell
        env:
          VERSION: ${{ github.ref_name }}
        run: |
          $version = "${env:VERSION}".TrimStart('v')
          New-Item -ItemType Directory -Path manifests-scoop -Force | Out-Null

          # CLI Scoop manifest
          $cliHash = (Get-FileHash artifacts/cli/eim.exe -Algorithm SHA256).Hash.ToLower()
          $cliJson = @{
              version = $version
              description = "ESP-IDF Installation Manager CLI - Setup tool for ESP-IDF development environment"
              homepage = "https://github.com/espressif/idf-im-ui"
              license = "MIT"
              architecture = @{
                  "64bit" = @{
                      url = "https://github.com/espressif/idf-im-ui/releases/download/${env:VERSION}/eim-cli-windows-x64.exe#/eim.exe"
                      hash = $cliHash
                  }
              }
              bin = "eim.exe"
              checkver = @{
                  github = "https://github.com/espressif/idf-im-ui"
              }
              autoupdate = @{
                  architecture = @{
                      "64bit" = @{
                          url = "https://github.com/espressif/idf-im-ui/releases/download/v`$version/eim-cli-windows-x64.exe#/eim.exe"
                      }
                  }
              }
          }
          $cliJson | ConvertTo-Json -Depth 10 | Out-File -FilePath manifests-scoop/eim-cli.json -Encoding UTF8

          # GUI Scoop manifest
          $guiHash = (Get-FileHash artifacts/gui/eim.exe -Algorithm SHA256).Hash.ToLower()
          $guiJson = @{
              version = $version
              description = "ESP-IDF Installation Manager GUI - Graphical setup tool for ESP-IDF development environment"
              homepage = "https://github.com/espressif/idf-im-ui"
              license = "MIT"
              architecture = @{
                  "64bit" = @{
                      url = "https://github.com/espressif/idf-im-ui/releases/download/${env:VERSION}/eim-gui-windows-x64.exe#/eim-gui.exe"
                      hash = $guiHash
                  }
              }
              bin = "eim-gui.exe"
              shortcuts = @(
                  @("eim-gui.exe", "ESP-IDF Installation Manager")
              )
              checkver = @{
                  github = "https://github.com/espressif/idf-im-ui"
              }
              autoupdate = @{
                  architecture = @{
                      "64bit" = @{
                          url = "https://github.com/espressif/idf-im-ui/releases/download/v`$version/eim-gui-windows-x64.exe#/eim-gui.exe"
                      }
                  }
              }
          }
          $guiJson | ConvertTo-Json -Depth 10 | Out-File -FilePath manifests-scoop/eim.json -Encoding UTF8

          Write-Host "Generated Scoop manifests"

      - name: Upload Scoop manifests to GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload ${{ github.ref_name }} manifests-scoop/*.json --clobber
        shell: bash

  # WinGet submission using winget-releaser
  publish-winget-cli:
    name: Publish CLI to WinGet
    needs: [build-cli, update-release-info]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'created'
    steps:
      - name: Publish EIM-CLI to WinGet
        uses: vedantmgoyal9/winget-releaser@v2
        with:
          identifier: Espressif.EIM-CLI
          installers-regex: 'eim-cli-windows-x64\.exe$'
          token: ${{ secrets.WINGET_PAT }}
          fork-user: Hahihula

  publish-winget-gui:
    name: Publish GUI to WinGet
    needs: [build-gui, update-release-info]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'created'
    steps:
      - name: Publish EIM to WinGet
        uses: vedantmgoyal9/winget-releaser@v2
        with:
          identifier: Espressif.EIM
          installers-regex: 'eim-gui-windows-x64\.msi$'
          token: ${{ secrets.WINGET_PAT }}
          fork-user: Hahihula
