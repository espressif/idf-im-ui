name: Build Offline Installer Archives

on:
  workflow_call:
    inputs:
      ref:
        required: true
        type: string
      run_id:
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      DL_DISTRIBUTION_ID:
        required: true

  workflow_dispatch:
    inputs:
      run_id:
        description: "The run id from which to take binaries"
        required: true
        type: string

jobs:
  build-offline-archives:
    name: Build Offline Archives (${{ matrix.package_name }})
    runs-on: ${{ matrix.os }}
    continue-on-error: true

    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            package_name: linux-x64
          - os: ubuntu-24.04-arm
            package_name: linux-aarch64
          - os: windows-latest
            package_name: windows-x64
          - os: macos-latest
            package_name: macos-aarch64
          - os: macos-13
            package_name: macos-x64
    steps:
      - name: Download offline_installer_builder artifact
        uses: actions/download-artifact@v5
        with:
          pattern: offline_installer_builder-${{ matrix.package_name }}-*
          merge-multiple: true
          path: ./
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ inputs.run_id || github.run_id }}

      - name: Download eim artifact
        uses: actions/download-artifact@v4
        with:
          pattern: eim-cli-${{ matrix.package_name }}-*
          merge-multiple: true
          path: ./
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ inputs.run_id || github.run_id }}

      - name: Make binary executable (Unix)
        if: runner.os != 'Windows'
        run: |
          chmod +x ./offline_installer_builder
          chmod +x ./eim

      - name: Install tooling
        run: |
          cargo install --git https://github.com/astral-sh/uv uv

      - name: Run offline_installer_builder
        run: |
          if [ "${{ runner.os }}" = "Windows" ]; then
            ./offline_installer_builder.exe -c default
          else
            ./offline_installer_builder -c default
          fi
        shell: bash

      - name: Bundle offline installer
        run: |
          # Find the archive file
          ARCHIVE_FILE=$(find . -name "archive_v*.zst" -type f | head -1)
          if [ -z "$ARCHIVE_FILE" ]; then
            echo "Error: No archive_v*.zst file found"
            exit 1
          fi

          # Extract version from filename (e.g., archive_v1.2.3.zst -> 1.2.3)
          VERSION=$(basename "$ARCHIVE_FILE" | sed 's/archive_v\(.*\)\.zst/\1/')
          echo "Found version: $VERSION"

          # Create the README.md file with installation instructions based on the OS.
          if [ "${{ runner.os }}" = "Windows" ]; then
            README_CONTENT="To install, use Powershell and run the following command in the terminal:\n\n\`eim install --use-local-archive $(basename "$ARCHIVE_FILE")\`"
          else
            README_CONTENT="To install, run the following command in your terminal:\n\n\`eim install --use-local-archive $(basename "$ARCHIVE_FILE")\`"
          fi
          echo -e "$README_CONTENT" > README.md

          # Create zip archive with eim binary and archive file
          if [ "${{ runner.os }}" = "Windows" ]; then
            7z a "offline_installer-${{ matrix.package_name }}-${VERSION}.zip" "$ARCHIVE_FILE" "./eim.exe" "README.md"
          else
            zip "offline_installer-${{ matrix.package_name }}-${VERSION}.zip" "$ARCHIVE_FILE" "./eim" "README.md"
          fi

          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Upload offline installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}
          path: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}.zip
          retention-days: 30

      # Release assets are limited to 2gb, until optimisation makes the archive less than 2gigs...
      # - name: Upload to release assets
      #   if: github.event_name == 'release'
      #   uses: actions/upload-release-asset@v1
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     upload_url: ${{ github.event.release.upload_url }}
      #     asset_path: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}.zip
      #     asset_name: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}.zip
      #     asset_content_type: application/zip

      - name: Upload installer to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-east-1
          VERSION: ${{ env.VERSION }}
          PACKAGE_NAME: ${{ matrix.package_name }}
          FILENAME: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}.zip
        shell: bash
        run: |
          # Only upload the installer ZIP
          aws s3 cp --acl=public-read "$FILENAME" "s3://espdldata/dl/eim/$FILENAME"

      - name: Create build info file
        env:
          VERSION: ${{ env.VERSION }}
          PACKAGE_NAME: ${{ matrix.package_name }}
          FILENAME: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}.zip
        shell: bash
        run: |
          # Create build info file
          jq -n \
            --arg version "$VERSION" \
            --arg platform "$PACKAGE_NAME" \
            --arg filename "$FILENAME" \
            '{"version": $version, "platform": $platform, "filename": $filename}' \
            > build-info.json

      - name: Save build info as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-info-${{ matrix.package_name }}
          path: build-info.json

  update-json:
    needs: build-offline-archives
    runs-on: ubuntu-latest
    steps:
      - name: Download all build info artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-info-*
          merge-multiple: true
          path: build-infos/

      - name: Update offline_archives.json
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-east-1
          DL_DISTRIBUTION_ID: ${{ secrets.DL_DISTRIBUTION_ID }}
          VERSION: ${{ env.VERSION }}
        shell: bash
        run: |
          # Download existing JSON or create empty array
          if curl -f -s -o offline_archives.json http://dl.espressif.com/dl/eim/offline_archives.json; then
            echo "Downloaded existing offline_archives.json"
            if ! jq empty offline_archives.json 2>/dev/null; then
              echo "Downloaded JSON is invalid, creating new empty array"
              echo "[]" > offline_archives.json
            fi
          else
            echo "offline_archives.json does not exist, creating new empty array"
            echo "[]" > offline_archives.json
          fi

          # Ensure valid JSON array
          if [ ! -s offline_archives.json ] || ! jq -e 'type == "array"' offline_archives.json >/dev/null 2>&1; then
            echo "File is empty or not a valid JSON array, initializing with empty array"
            echo "[]" > offline_archives.json
          fi

          # Collect all new build info
          new_entries="[]"
          for build_info in build-infos/*.json; do
            if [ -f "$build_info" ]; then
              entry=$(cat "$build_info")
              new_entries=$(echo "$new_entries" | jq ". + [$entry]")
            fi
          done

          # Remove existing entries with same filenames, then add all new entries
          updated_json=$(jq --argjson new_entries "$new_entries" '
            . as $original |
            ($new_entries | map(.filename)) as $new_filenames |
            ($original | map(select(.filename as $f | $new_filenames | index($f) | not))) + $new_entries
          ' offline_archives.json)

          echo "$updated_json" > updated_archives.json

          # Verify the updated JSON is valid
          if ! jq empty updated_archives.json 2>/dev/null; then
            echo "Error: Generated JSON is invalid"
            exit 1
          fi

          # Upload updated JSON to S3
          aws s3 cp --acl=public-read updated_archives.json s3://espdldata/dl/eim/offline_archives.json

          # Invalidate Cache
          aws cloudfront create-invalidation --distribution-id ${DL_DISTRIBUTION_ID} --paths "/dl/eim/offline_archives.json"

  Autotest-CLI-Offline:
    needs: [build-offline-archives]
    if: needs.build-offline-archives.result == 'success'
    uses: ./.github/workflows/test_offline.yml
    with:
      ref: ${{ inputs.ref || github.ref }}
      run_id: ${{ github.run_id }}
