name: Build Offline Installer Archives

on:
  workflow_call:
    inputs:
      ref:
        required: true
        type: string
      run_id:
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      DL_DISTRIBUTION_ID:
        required: true

  workflow_dispatch:
    inputs:
      run_id:
        description: "The run id from which to take binaries"
        required: true
        type: string
      update_json:
        description: "Update offline_archives.json in S3"
        required: false
        type: boolean
        default: true

jobs:
  build-offline-archives:
    name: Build Offline Archives (${{ matrix.package_name }})
    runs-on: ${{ matrix.os }}
    continue-on-error: true

    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            package_name: linux-x64
          - os: ubuntu-24.04-arm
            package_name: linux-aarch64
          - os: windows-latest
            package_name: windows-x64
          - os: macos-latest
            package_name: macos-aarch64
          - os: macos-13
            package_name: macos-x64
    steps:
      - name: Download offline_installer_builder artifact
        uses: actions/download-artifact@v5
        with:
          pattern: offline_installer_builder-${{ matrix.package_name }}-*
          merge-multiple: true
          path: ./
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ inputs.run_id || github.run_id }}

      - name: Download eim artifact
        uses: actions/download-artifact@v4
        with:
          pattern: eim-cli-${{ matrix.package_name }}-*
          merge-multiple: true
          path: ./
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ inputs.run_id || github.run_id }}

      - name: Make binary executable (Unix)
        if: runner.os != 'Windows'
        run: |
          chmod +x ./offline_installer_builder
          chmod +x ./eim

      - name: Install tooling
        run: |
          cargo install --git https://github.com/astral-sh/uv uv

      - name: Run offline_installer_builder
        run: |
          if [ "${{ runner.os }}" = "Windows" ]; then
            ./offline_installer_builder.exe -c default
          else
            ./offline_installer_builder -c default
          fi
        shell: bash

      - name: Bundle offline installer
        run: |
          # Find the archive file
          ARCHIVE_FILE=$(find . -name "archive_v*.zst" -type f | head -1)
          if [ -z "$ARCHIVE_FILE" ]; then
            echo "Error: No archive_v*.zst file found"
            exit 1
          fi

          # Extract version from filename (e.g., archive_v1.2.3.zst -> 1.2.3)
          VERSION=$(basename "$ARCHIVE_FILE" | sed 's/archive_v\(.*\)\.zst/\1/')
          echo "Found version: $VERSION"

          # Create the README.md file with installation instructions based on the OS.
          if [ "${{ runner.os }}" = "Windows" ]; then
            README_CONTENT="To install, use Powershell and run the following command in the terminal:\n\n\`eim install --use-local-archive $(basename "$ARCHIVE_FILE")\`"
          else
            README_CONTENT="To install, run the following command in your terminal:\n\n\`eim install --use-local-archive $(basename "$ARCHIVE_FILE")\`"
          fi
          echo -e "$README_CONTENT" > README.md

          # Create zip archive with eim binary and archive file
          if [ "${{ runner.os }}" = "Windows" ]; then
            7z a "offline_installer-${{ matrix.package_name }}-${VERSION}.zip" "$ARCHIVE_FILE" "./eim.exe" "README.md"
          else
            zip "offline_installer-${{ matrix.package_name }}-${VERSION}.zip" "$ARCHIVE_FILE" "./eim" "README.md"
          fi

          echo "VERSION=$VERSION" >> $GITHUB_ENV
        shell: bash

      - name: Upload offline installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}
          path: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}.zip
          retention-days: 30

      - name: Create build info file
        env:
          VERSION: ${{ env.VERSION }}
          PACKAGE_NAME: ${{ matrix.package_name }}
          FILENAME: offline_installer-${{ matrix.package_name }}-${{ env.VERSION }}.zip
        shell: bash
        run: |
          # Calculate file size in bytes
          if [ "${{ runner.os }}" = "macOS" ]; then
            FILE_SIZE=$(stat -f %z "$FILENAME")
          else
            FILE_SIZE=$(stat -c %s "$FILENAME")
          fi
          # Create build info file with size
          jq -n \
            --arg version "$VERSION" \
            --arg platform "$PACKAGE_NAME" \
            --arg filename "$FILENAME" \
            --arg size "$FILE_SIZE" \
            '{"version": $version, "platform": $platform, "filename": $filename, "size": ($size | tonumber)}' \
            > build-info.json

      - name: Save build info as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-info-${{ matrix.package_name }}
          path: build-info.json

  update-json:
    needs: build-offline-archives
    runs-on: ubuntu-latest
    if: ${{ inputs.update_json }}
    steps:
      - name: Download all build info artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-info-*
          path: build-infos/

      - name: Update offline_archives.json
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-east-1
          DL_DISTRIBUTION_ID: ${{ secrets.DL_DISTRIBUTION_ID }}
        shell: bash
        run: |
          # Debug: List downloaded artifacts
          echo "Listing downloaded artifacts:"
          find build-infos/ -type f

          # Download existing JSON or create empty array
          aws s3 cp s3://espdldata/dl/eim/offline_archives.json offline_archives.json 2>/dev/null || echo "[]" > offline_archives.json

          # Ensure valid JSON array
          if ! jq -e 'type == "array"' offline_archives.json >/dev/null 2>&1; then
            echo "Invalid or not an array, initializing with empty array"
            echo "[]" > offline_archives.json
          fi

          # Debug: Show current offline_archives.json
          echo "Current offline_archives.json:"
          cat offline_archives.json

          # Collect all new build info
          new_entries="[]"
          for build_info in build-infos/*/build-info.json; do
            if [ -f "$build_info" ]; then
              echo "Processing $build_info"
              entry=$(cat "$build_info")
              new_entries=$(echo "$new_entries" | jq --argjson entry "$entry" '. + [$entry]')
            else
              echo "No build-info.json found in $build_info"
            fi
          done

          # Debug: Show new_entries
          echo "New entries:"
          echo "$new_entries"

          # Remove existing entries with same filenames, then add all new entries
          updated_json=$(jq --argjson new_entries "$new_entries" '
            . as $original |
            ($new_entries | map(.filename)) as $new_filenames |
            ($original | map(select(.filename as $f | $new_filenames | index($f) | not))) + $new_entries
          ' offline_archives.json)

          # Debug: Show updated JSON
          echo "Updated JSON:"
          echo "$updated_json"

          # Write updated JSON to file
          echo "$updated_json" > updated_archives.json

          # Verify the updated JSON is valid
          if ! jq empty updated_archives.json 2>/dev/null; then
            echo "Error: Generated JSON is invalid"
            exit 1
          fi

          # Upload updated JSON to S3
          aws s3 cp --acl=public-read updated_archives.json s3://espdldata/dl/eim/offline_archives.json

          # Invalidate CloudFront cache
          aws cloudfront create-invalidation --distribution-id ${DL_DISTRIBUTION_ID} --paths "/dl/eim/offline_archives.json"

  Autotest-CLI-Offline:
    needs: [build-offline-archives]
    if: needs.build-offline-archives.result == 'success'
    uses: ./.github/workflows/test_offline.yml
    with:
      ref: ${{ inputs.ref || github.ref }}
      run_id: ${{ github.run_id }}
