# Cancel in-progress and queued build runs for the same PR when a new commit is pushed,
# so only the latest commit is built. Opt out by including "no-cancel-pipeline" in the commit message.
name: Cancel old commit build (PR)

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - master
    paths-ignore:
      - "dl_page/**"
      - "docs/**"
      - ".github/workflows/dl_page.yml"
      - ".github/workflows/docs_build.yml"

permissions:
  actions: write
  contents: read

jobs:
  cancel-old-builds:
    name: Cancel outdated build runs
    runs-on: ubuntu-latest
    steps:
      - name: Get head commit message
        id: commit_msg
        uses: actions/github-script@v7
        with:
          script: |
            const { data } = await github.rest.repos.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha
            });
            const message = (data.commit?.message || '').replace(/\n/g, ' ').toLowerCase();
            core.setOutput('message', message);
            core.info(`Head commit message (first 200 chars): ${message.slice(0, 200)}`);

      - name: Skip cancel when commit has no-cancel-pipeline
        if: contains(steps.commit_msg.outputs.message, 'no-cancel-pipeline')
        run: |
          echo "Commit message contains 'no-cancel-pipeline'; skipping cancellation."
          exit 0

      - name: Cancel older build runs for this PR
        if: ${{ !contains(steps.commit_msg.outputs.message, 'no-cancel-pipeline') }}
        uses: actions/github-script@v7
        with:
          script: |
            const ref = context.ref; // e.g. refs/pull/123/merge
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Find "Unified Build Workflow" (build.yaml)
            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner,
              repo,
              per_page: 100
            });
            const buildWorkflow = workflows.workflows.find(
              w => w.path === '.github/workflows/build.yaml' || w.name === 'Unified Build Workflow'
            );
            if (!buildWorkflow) {
              core.warning('Unified Build Workflow not found; skipping cancel.');
              return;
            }

            const workflowId = buildWorkflow.id;
            const runsToCancel = [];

            for (const status of ['in_progress', 'queued']) {
              const { data } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                workflow_id: workflowId,
                ref,
                status,
                per_page: 100
              });
              runsToCancel.push(...data.workflow_runs);
            }

            // Dedupe by run id and sort by run_number descending (newest first)
            const byId = new Map(runsToCancel.map(r => [r.id, r]));
            const sorted = [...byId.values()].sort((a, b) => b.run_number - a.run_number);

            if (sorted.length === 0) {
              core.info('No in-progress or queued build runs to cancel.');
              return;
            }

            // Keep the newest run (highest run_number), cancel the rest
            const toCancel = sorted.slice(1);
            core.info(`Keeping run #${sorted[0].run_number} (id ${sorted[0].id}); cancelling ${toCancel.length} older run(s).`);

            for (const run of toCancel) {
              await github.rest.actions.cancelWorkflowRun({
                owner,
                repo,
                run_id: run.id
              });
              core.info(`Cancelled run #${run.run_number} (id ${run.id}).`);
            }
